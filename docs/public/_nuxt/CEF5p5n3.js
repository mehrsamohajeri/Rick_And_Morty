import{Y as L,G as N,Z as v,C as $,$ as U,g as B,a0 as A,B as I,P as w,a1 as j,a2 as H,u as q,a3 as x,a4 as W,a5 as z,q as G,a6 as Y,a7 as Z,a8 as M}from"./DAraDU9o.js";function sa(){const t=L().public.apiBase;return{getCharacters:async(e=1,u)=>{const d=new URLSearchParams;d.set("page",String(e)),u?.trim()&&d.set("name",u.trim());const s=`${t}/character?${d.toString()}`;try{return await $fetch(s)}catch{return{info:{count:0,pages:0,next:null,prev:null},results:[]}}},getCharacter:async e=>{try{return await $fetch(`${t}/character/${e}`)}catch{return null}},getEpisodes:async e=>{if(e.length===0)return[];const u=e.length===1?`${t}/episode/${e[0]}`:`${t}/episode/${e.join(",")}`,d=await $fetch(u);return Array.isArray(d)?d:[d]},getLocations:async e=>{if(e.length===0)return[];const u=e.length===1?`${t}/location/${e[0]}`:`${t}/location/${e.join(",")}`,d=await $fetch(u);return Array.isArray(d)?d:[d]},extractIdFromUrl:e=>{const u=e.match(/\/(\d+)\/?$/);return u?parseInt(u[1],10):0}}}const J={trailing:!0};function Q(a,t=25,i={}){if(i={...J,...i},!Number.isFinite(t))throw new TypeError("Expected `wait` to be a finite number");let o,r,y=[],n,e;const u=(h,g)=>(n=X(a,h,g),n.finally(()=>{if(n=null,i.trailing&&e&&!r){const b=u(h,e);return e=null,b}}),n),d=function(...h){return i.trailing&&(e=h),n||new Promise(g=>{const b=!r&&i.leading;clearTimeout(r),r=setTimeout(()=>{r=null;const c=i.leading?o:u(this,h);e=null;for(const _ of y)_(c);y=[]},t),b?(o=u(this,h),g(o)):y.push(g)})},s=h=>{h&&(clearTimeout(h),r=null)};return d.isPending=()=>!!r,d.cancel=()=>{s(r),y=[],e=null},d.flush=()=>{if(s(r),!e||n)return;const h=e;return e=null,u(this,h)},d}async function X(a,t,i){return await a.apply(t,i)}const K=Symbol.for("nuxt:client-only"),k=a=>a==="defer"||a===!1;function oa(...a){const t=typeof a[a.length-1]=="string"?a.pop():void 0;aa(a[0],a[1])&&a.unshift(t);let[i,o,r={}]=a,y=!1;const n=B(()=>Z(i));if(typeof n.value!="string")throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if(typeof o!="function")throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const e=N();r.server??=!0,r.default??=ta,r.getCachedData??=T,r.lazy??=!1,r.immediate??=!0,r.deep??=v.deep,r.dedupe??="cancel",r._functionName,e._asyncData[n.value];function u(){const c={cause:"initial",dedupe:r.dedupe};return e._asyncData[n.value]?._init||(c.cachedData=r.getCachedData(n.value,e,{cause:"initial"}),e._asyncData[n.value]=R(e,n.value,o,r,c.cachedData)),()=>e._asyncData[n.value].execute(c)}const d=u(),s=e._asyncData[n.value];s._deps++;const h=r.server!==!1&&e.payload.serverRendered;{let c=function(f){const l=e._asyncData[f];l?._deps&&(l._deps--,l._deps===0&&l?._off())};const _=Y();if(_&&h&&r.immediate&&!_.sp&&(_.sp=[]),_&&!_._nuxtOnBeforeMountCbs){_._nuxtOnBeforeMountCbs=[];const f=_._nuxtOnBeforeMountCbs;W(()=>{f.forEach(l=>{l()}),f.splice(0,f.length)}),z(()=>f.splice(0,f.length))}const p=_&&(_._nuxtClientOnly||G(K,!1));h&&e.isHydrating&&(s.error.value||s.data.value!=null)?(s.pending.value=!1,s.status.value=s.error.value?"error":"success"):_&&(!p&&e.payload.serverRendered&&e.isHydrating||r.lazy)&&r.immediate?_._nuxtOnBeforeMountCbs.push(d):r.immediate&&d();const D=A(),m=$(n,(f,l)=>{if((f||l)&&f!==l){y=!0;const S=e._asyncData[l]?.data.value!==v.value,V=e._asyncDataPromises[l]!==void 0,O={cause:"initial",dedupe:r.dedupe};if(!e._asyncData[f]?._init){let E;l&&S?E=e._asyncData[l].data.value:(E=r.getCachedData(f,e,{cause:"initial"}),O.cachedData=E),e._asyncData[f]=R(e,f,o,r,E)}e._asyncData[f]._deps++,l&&c(l),(r.immediate||S||V)&&e._asyncData[f].execute(O),M(()=>{y=!1})}},{flush:"sync"}),C=r.watch?$(r.watch,()=>{y||(e._asyncData[n.value]?._execute.isPending()&&M(()=>{e._asyncData[n.value]?._execute.flush()}),e._asyncData[n.value]?._execute({cause:"watch",dedupe:r.dedupe}))}):()=>{};D&&U(()=>{m(),C(),c(n.value)})}const g={data:P(()=>e._asyncData[n.value]?.data),pending:P(()=>e._asyncData[n.value]?.pending),status:P(()=>e._asyncData[n.value]?.status),error:P(()=>e._asyncData[n.value]?.error),refresh:(...c)=>e._asyncData[n.value]?._init?e._asyncData[n.value].execute(...c):u()(),execute:(...c)=>g.refresh(...c),clear:()=>{const c=e._asyncData[n.value];if(c?._abortController)try{c._abortController.abort(new DOMException("AsyncData aborted by user.","AbortError"))}finally{c._abortController=void 0}F(e,n.value)}},b=Promise.resolve(e._asyncDataPromises[n.value]).then(()=>g);return Object.assign(b,g),b}function P(a){return B({get(){return a()?.value},set(t){const i=a();i&&(i.value=t)}})}function aa(a,t){return!(typeof a=="string"||typeof a=="object"&&a!==null||typeof a=="function"&&typeof t=="function")}function F(a,t){t in a.payload.data&&(a.payload.data[t]=void 0),t in a.payload._errors&&(a.payload._errors[t]=v.errorValue),a._asyncData[t]&&(a._asyncData[t].data.value=void 0,a._asyncData[t].error.value=v.errorValue,a._asyncData[t].pending.value=!1,a._asyncData[t].status.value="idle"),t in a._asyncDataPromises&&(a._asyncDataPromises[t]=void 0)}function ea(a,t){const i={};for(const o of t)i[o]=a[o];return i}function R(a,t,i,o,r){a.payload._errors[t]??=v.errorValue;const y=o.getCachedData!==T,n=i,e=o.deep?I:w,u=r!=null,d=a.hook("app:data:refresh",async h=>{(!h||h.includes(t))&&await s.execute({cause:"refresh:hook"})}),s={data:e(u?r:o.default()),pending:w(!u),error:x(a.payload._errors,t),status:w("idle"),execute:(...h)=>{const[g,b=void 0]=h,c=g&&b===void 0&&typeof g=="object"?g:{};if(a._asyncDataPromises[t]&&k(c.dedupe??o.dedupe))return a._asyncDataPromises[t];if(c.cause==="initial"||a.isHydrating){const D="cachedData"in c?c.cachedData:o.getCachedData(t,a,{cause:c.cause??"refresh:manual"});if(D!=null)return a.payload.data[t]=s.data.value=D,s.error.value=v.errorValue,s.status.value="success",Promise.resolve(D)}s.pending.value=!0,s._abortController&&s._abortController.abort(new DOMException("AsyncData request cancelled by deduplication","AbortError")),s._abortController=new AbortController,s.status.value="pending";const _=new AbortController,p=new Promise((D,m)=>{try{const C=c.timeout??o.timeout,f=ra([s._abortController?.signal,c?.signal],_.signal,C);if(f.aborted){const l=f.reason;m(l instanceof Error?l:new DOMException(String(l??"Aborted"),"AbortError"));return}return f.addEventListener("abort",()=>{const l=f.reason;m(l instanceof Error?l:new DOMException(String(l??"Aborted"),"AbortError"))},{once:!0,signal:_.signal}),Promise.resolve(n(a,{signal:f})).then(D,m)}catch(C){m(C)}}).then(async D=>{let m=D;o.transform&&(m=await o.transform(D)),o.pick&&(m=ea(m,o.pick)),a.payload.data[t]=m,s.data.value=m,s.error.value=v.errorValue,s.status.value="success"}).catch(D=>{if(a._asyncDataPromises[t]&&a._asyncDataPromises[t]!==p||s._abortController?.signal.aborted)return a._asyncDataPromises[t];if(typeof DOMException<"u"&&D instanceof DOMException&&D.name==="AbortError")return s.status.value="idle",a._asyncDataPromises[t];s.error.value=H(D),s.data.value=q(o.default()),s.status.value="error"}).finally(()=>{s.pending.value=!1,_.abort(),delete a._asyncDataPromises[t]});return a._asyncDataPromises[t]=p,a._asyncDataPromises[t]},_execute:Q((...h)=>s.execute(...h),0,{leading:!0}),_default:o.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{d(),a._asyncData[t]?._init&&(a._asyncData[t]._init=!1),y||j(()=>{a._asyncData[t]?._init||(F(a,t),s.execute=()=>Promise.resolve(),s.data.value=v.value)})}};return s}const ta=()=>v.value,T=(a,t,i)=>{if(t.isHydrating)return t.payload.data[a];if(i.cause!=="refresh:manual"&&i.cause!=="refresh:hook")return t.static.data[a]};function ra(a,t,i){const o=a.filter(n=>!!n);if(typeof i=="number"&&i>=0){const n=AbortSignal.timeout?.(i);n&&o.push(n)}if(AbortSignal.any)return AbortSignal.any(o);const r=new AbortController;for(const n of o)if(n.aborted){const e=n.reason??new DOMException("Aborted","AbortError");try{r.abort(e)}catch{r.abort()}return r.signal}const y=()=>{const e=o.find(u=>u.aborted)?.reason??new DOMException("Aborted","AbortError");try{r.abort(e)}catch{r.abort()}};for(const n of o)n.addEventListener?.("abort",y,{once:!0,signal:t});return r.signal}export{oa as a,sa as u};
